use super::{Report, ReportConfig, ReportData};
use crate::util::percentage;

use std::{
    collections::BTreeMap,
    fs::File,
    io::{Read, Write},
    path::{Path, PathBuf},
};

use fehler::throws;
use rust_playground_top_crates::*;
use serde::Deserialize;
use serde::Serialize;
use stable_eyre::eyre::{Error, WrapErr};

#[derive(Debug)]
pub(super) struct TopCrateInfo {
    name: String,
    version: semver::Version,
    id: String,
}

impl Report {
    #[throws]
    pub(super) async fn top_crates(&self, _config: &ReportConfig) -> Vec<TopCrateInfo> {
        let path = self.data_dir.join("crate-information.json");

        // if the `crate-information.json` doesn't exist, generate it
        if !path.exists() {
            let copy_data_dir = self.data_dir.to_path_buf();
            tokio::task::spawn_blocking(move || generate_crate_information(&copy_data_dir))
                .await
                .wrap_err("Failed to spawn blocking task")?
                .wrap_err("Failed to generate top-crates files")?;
        }

        tokio::task::spawn_blocking(move || load_top_crates(&path))
            .await
            .wrap_err("Failed to load top crates")??
    }

    #[throws]
    pub(super) fn write_top_crates(&self, _config: &ReportConfig, data: &ReportData) {
        let stable_crates = data
            .top_crates
            .iter()
            .filter(|c| c.version.major >= 1)
            .count() as u64;
        let total_crates = data.top_crates.len() as u64;
        let percentage = percentage(stable_crates, total_crates);

        let output = self.output_dir().join("top_crate.csv");
        let output_file = &mut File::create(output.clone())
            .wrap_err_with(|| format!("Failed to create file from path {:?}", &output))?;

        let mut csv = csv::Writer::from_writer(output_file);

        csv.write_record(&["Measurement".to_string(), "Value".to_string()])
            .wrap_err("Failed to write headers while writing top crates")?;

        csv.write_record(&[
            "Total 'significant' crates".to_string(),
            total_crates.to_string(),
        ])
        .wrap_err("Failed to write Total Significant Crates while writing top crates")?;

        csv.write_record(&[
            "crates at 1.0 or higher".to_string(),
            percentage.to_string(),
        ])
        .wrap_err("Failed to write High Percentage crates while writing top crates")?;
    }
}

/// Loads the `crate-information.json` generated by the [top-crates playground code][pc].
///
/// [pc]: https://github.com/integer32llc/rust-playground/tree/master/top-crates
#[throws]
fn load_top_crates(path: &Path) -> Vec<TopCrateInfo> {
    #[derive(Deserialize)]
    struct TC {
        name: String,
        version: String,
        id: String,
    }
    let data = std::fs::read_to_string(&path.clone())
        .wrap_err_with(|| format!("Failed to read data from path {:?}", &path))?;
    let data: Vec<TC> = serde_json::from_str(&data)
        .wrap_err_with(|| format!("Failed to serialize data: {}", data))?;
    let mut vec = Vec::new();
    for TC { name, version, id } in data {
        let version = semver::Version::parse(&version.clone())
            .wrap_err_with(|| format!("Failed to parse version from {}", version))?;
        vec.push(TopCrateInfo { name, version, id });
    }
    vec
}

/// A Cargo.toml file.
#[derive(Serialize)]
struct TomlManifest {
    package: TomlPackage,
    profile: Profiles,
    #[serde(serialize_with = "toml::ser::tables_last")]
    dependencies: BTreeMap<String, DependencySpec>,
}

/// Header of Cargo.toml file.
#[derive(Serialize)]
struct TomlPackage {
    name: String,
    version: String,
    authors: Vec<String>,
    resolver: String,
}

/// A profile section in a Cargo.toml file
#[derive(Serialize)]
#[serde(rename_all = "kebab-case")]
struct Profile {
    codegen_units: u32,
    incremental: bool,
}

/// Available profile types
#[derive(Serialize)]
struct Profiles {
    dev: Profile,
    release: Profile,
}

#[throws]
pub fn generate_crate_information(base_directory: &PathBuf) {
    let mut f = File::open("crate-modifications.toml")
        .wrap_err("unable to open crate modifications file")?;
    let mut d = Vec::new();

    f.read_to_end(&mut d)
        .wrap_err("unable to read crate modifications file")?;

    let modifications: Modifications =
        toml::from_slice(&d).wrap_err("unable to parse crate modifications file")?;

    let (dependencies, infos) = rust_playground_top_crates::generate_info(&modifications);

    // Construct playground's Cargo.toml.
    let manifest = TomlManifest {
        package: TomlPackage {
            name: "playground".to_owned(),
            version: "0.0.1".to_owned(),
            authors: vec!["The Rust Playground".to_owned()],
            resolver: "2".to_owned(),
        },
        profile: Profiles {
            dev: Profile {
                codegen_units: 1,
                incremental: false,
            },
            release: Profile {
                codegen_units: 1,
                incremental: false,
            },
        },
        dependencies,
    };

    let cargo_toml = base_directory.join("Cargo.toml");
    write_manifest(manifest, &cargo_toml);

    let path = base_directory.join("crate-information.json");
    let mut f = File::create(&path)
        .unwrap_or_else(|e| panic!("Unable to create {}: {}", path.display(), e));
    serde_json::to_writer_pretty(&mut f, &infos)
        .unwrap_or_else(|e| panic!("Unable to write {}: {}", path.display(), e));
}

fn write_manifest(manifest: TomlManifest, path: impl AsRef<Path>) {
    let mut f = File::create(path).expect("Unable to create Cargo.toml");
    let content = toml::to_vec(&manifest).expect("Couldn't serialize TOML");
    f.write_all(&content).expect("Couldn't write Cargo.toml");
}
